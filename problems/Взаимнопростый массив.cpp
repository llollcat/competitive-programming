/*
ограничение по времени на тест
1 секунда
ограничение по памяти на тест
256 мегабайт
ввод
стандартный ввод
вывод
стандартный вывод

Вам задан массив из n элементов. Вам нужно превратить его во взаимнопростый массив за наименьшее количество действий.

За одно действие вы можете вставить любое положительное целое число, не превосходящее величины 109, в любое место массива.

Массив называется взаимнопростым, если любая пара соседних чисел взаимнопроста.

В теории чисел два числа a и b называются взаимнопростыми, если единственным положительным делителем обоих чисел является число 1.
Входные данные

В первой строке находится целое число n (1 ≤ n ≤ 1000) — количество элементов в массиве.

Во второй строке находятся n целых чисел ai (1 ≤ ai ≤ 109) — элементы массива a.
Выходные данные

В первой строке выведите целое число k — наименьшее количество элементов, которые нужно добавить в массив a, чтобы он стал взаимнопростым.

Во второй строке выведите n + k целых чисел aj — элементы массива a после добавления k элементов. Обратите внимание, что этот массив должен быть взаимнопростым, то есть все пары соседних элементов должны быть взаимнопросты. Также новый массив должен быть получен из исходного массива a добавлением ровно k элементов.

Если существует несколько решений, выведите любое.
Пример
Входные данные
Скопировать

3
2 7 28

Выходные данные
Скопировать

1
2 7 9 28

 */





#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;



int main() {
    long long n; cin >> n;
    vector<long long> a;

    long long k = 0;
    long long t1, t2;
    cin >> t2;
    for (long long i = 1, t; i<n; ++i ) {
        cin >> t1;
        a.push_back(t2);
        if  (__gcd(t1, t2)!= 1) {
            ++k;
            a.push_back(1);
        }


        t2 = t1;



    }
    a.push_back(t2);

    cout << k << endl;
    for (long long i: a)
        cout << i << " ";

    return 0;
}

 
